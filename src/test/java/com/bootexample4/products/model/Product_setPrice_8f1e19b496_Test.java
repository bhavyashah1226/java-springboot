/*
Test generated by RoostGPT for test JavaUnitTest using AI Type Open AI and AI Model gpt-4

1. Scenario: Setting a Positive Price Value
   Test to check whether the function accepts and correctly sets a positive price value.

2. Scenario: Setting a Zero Price Value
   Test to check whether the function correctly sets the price to zero.

3. Scenario: Setting a Negative Price Value
   Test to check the behavior of the function when we try to set a negative price value. The function should ideally throw an error or exception as a negative price doesn't make sense in a business context.

4. Scenario: Setting a Large Price Value
   Test to check whether the function can handle and correctly set a very large price value.

5. Scenario: Setting a Small Non-Zero Price Value
   Test to check whether the function can handle and correctly set a very small non-zero price value.

6. Scenario: Setting a Price Value with Many Decimal Places
   Test to check whether the function correctly handles a price value with many decimal places.

7. Scenario: Setting a Price Value with No Decimal Places
   Test to check whether the function correctly handles a price value with no decimal places.

8. Scenario: Setting a Null Price Value
   Test to check the behavior of the function when a null value is passed. The function should ideally throw a null pointer exception.

9. Scenario: Setting a Price Value of Type Other Than Double
   Test to check the behavior of the function when a value of type other than double is passed. The function should throw a type mismatch exception.

10. Scenario: Concurrent Price Setting
    Test to check the behavior of the function when multiple threads are trying to set the price concurrently. This will test the thread safety of the function.
*/
package com.bootexample4.products.model;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class Product_setPrice_8f1e19b496_Test {

    private Product product;

    @BeforeEach
    public void setUp() {
        product = new Product();
    }

    @Test
    public void testSetPositivePrice() {
        double price = 100.0;
        product.setPrice(price);
        assertEquals(price, product.getPrice());
    }

    @Test
    public void testSetZeroPrice() {
        double price = 0.0;
        product.setPrice(price);
        assertEquals(price, product.getPrice());
    }

    @Test
    public void testSetNegativePrice() {
        double price = -10.0;
        assertThrows(IllegalArgumentException.class, () -> product.setPrice(price));
    }

    @Test
    public void testSetLargePrice() {
        double price = Double.MAX_VALUE;
        product.setPrice(price);
        assertEquals(price, product.getPrice());
    }

    @Test
    public void testSetSmallPrice() {
        double price = Double.MIN_VALUE;
        product.setPrice(price);
        assertEquals(price, product.getPrice());
    }

    @Test
    public void testSetPriceWithManyDecimals() {
        double price = 100.123456789;
        product.setPrice(price);
        assertEquals(price, product.getPrice());
    }

    @Test
    public void testSetPriceWithNoDecimals() {
        double price = 100;
        product.setPrice(price);
        assertEquals(price, product.getPrice());
    }

    @Test
    public void testSetNullPrice() {
        assertThrows(NullPointerException.class, () -> product.setPrice(null));
    }

    @Test
    public void testSetPriceWithTypeMismatch() {
        assertThrows(ClassCastException.class, () -> product.setPrice("100"));
    }

    @Test
    public void testConcurrentPriceSetting() {
        assertDoesNotThrow(() -> {
            Thread t1 = new Thread(() -> product.setPrice(200.0));
            Thread t2 = new Thread(() -> product.setPrice(300.0));
            t1.start();
            t2.start();
            t1.join();
            t2.join();
        });
    }
}
